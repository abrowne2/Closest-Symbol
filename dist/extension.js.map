{"version":3,"file":"extension.js","mappings":"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","sources":["webpack://closest-symbol/./node_modules/string-similarity/src/index.js","webpack://closest-symbol/./src/closestSymbol.ts","webpack://closest-symbol/external commonjs \"vscode\"","webpack://closest-symbol/webpack/bootstrap","webpack://closest-symbol/./src/extension.ts"],"sourcesContent":["module.exports = {\n\tcompareTwoStrings:compareTwoStrings,\n\tfindBestMatch:findBestMatch\n};\n\nfunction compareTwoStrings(first, second) {\n\tfirst = first.replace(/\\s+/g, '')\n\tsecond = second.replace(/\\s+/g, '')\n\n\tif (first === second) return 1; // identical or empty\n\tif (first.length < 2 || second.length < 2) return 0; // if either is a 0-letter or 1-letter string\n\n\tlet firstBigrams = new Map();\n\tfor (let i = 0; i < first.length - 1; i++) {\n\t\tconst bigram = first.substring(i, i + 2);\n\t\tconst count = firstBigrams.has(bigram)\n\t\t\t? firstBigrams.get(bigram) + 1\n\t\t\t: 1;\n\n\t\tfirstBigrams.set(bigram, count);\n\t};\n\n\tlet intersectionSize = 0;\n\tfor (let i = 0; i < second.length - 1; i++) {\n\t\tconst bigram = second.substring(i, i + 2);\n\t\tconst count = firstBigrams.has(bigram)\n\t\t\t? firstBigrams.get(bigram)\n\t\t\t: 0;\n\n\t\tif (count > 0) {\n\t\t\tfirstBigrams.set(bigram, count - 1);\n\t\t\tintersectionSize++;\n\t\t}\n\t}\n\n\treturn (2.0 * intersectionSize) / (first.length + second.length - 2);\n}\n\nfunction findBestMatch(mainString, targetStrings) {\n\tif (!areArgsValid(mainString, targetStrings)) throw new Error('Bad arguments: First argument should be a string, second should be an array of strings');\n\t\n\tconst ratings = [];\n\tlet bestMatchIndex = 0;\n\n\tfor (let i = 0; i < targetStrings.length; i++) {\n\t\tconst currentTargetString = targetStrings[i];\n\t\tconst currentRating = compareTwoStrings(mainString, currentTargetString)\n\t\tratings.push({target: currentTargetString, rating: currentRating})\n\t\tif (currentRating > ratings[bestMatchIndex].rating) {\n\t\t\tbestMatchIndex = i\n\t\t}\n\t}\n\t\n\t\n\tconst bestMatch = ratings[bestMatchIndex]\n\t\n\treturn { ratings: ratings, bestMatch: bestMatch, bestMatchIndex: bestMatchIndex };\n}\n\nfunction areArgsValid(mainString, targetStrings) {\n\tif (typeof mainString !== 'string') return false;\n\tif (!Array.isArray(targetStrings)) return false;\n\tif (!targetStrings.length) return false;\n\tif (targetStrings.find( function (s) { return typeof s !== 'string'})) return false;\n\treturn true;\n}\n","import * as vscode from 'vscode';\nimport * as similar from 'string-similarity';\n\ninterface Closest {\n    symbol: string;\n    range: vscode.Range;\n    rating: number;\n    distanceFromCursor: number;\n}\n\nlet closest: Closest | null = null;\n\n// TODO fix this for local unsaved files?\nconst gotoLineByNumber = async function(line: number) {\n    await vscode.commands.executeCommand(\"editor.action.goToLocations\", \n        vscode.window.activeTextEditor?.document.uri,\n        vscode.window.activeTextEditor?.selection.active,\n        [{\n            uri: vscode.window.activeTextEditor?.document.uri,\n            range: {\n                startLineNumber: line,\n                startColumn: 0,\n                endLineNumber: line,\n                endColumn: 0\n            }\n        }],\n        'goto',\n        'No super implementation found'\n    );\n};\n\nconst gotoRange = async function(range: vscode.Range) {\n    await vscode.commands.executeCommand(\"editor.action.goToLocations\", \n        vscode.window.activeTextEditor?.document.uri,\n        vscode.window.activeTextEditor?.selection.active,\n        [{\n            uri: vscode.window.activeTextEditor?.document.uri,\n            range: {\n                startLineNumber: range.start.line+1,\n                startColumn: 0, \n                endLineNumber: range.end.line+1,\n                endColumn: 0\n            }\n        }],\n        'goto',\n        'No super implementation found'\n    );\n};\n\nconst tokenIsNotKeyword = (token: string): boolean => {\n    return token !== \"let\" && token !== \"var\" && token !== \"to\"\n        && token !== \"const\" && token !== \"await\" && token !== \"return\";\n};\n\nconst checkLineRangeForSymbolMatch = async function(pattern: string, line: vscode.TextLine, cursorPos: vscode.Position) {\n    let currentLineRange: vscode.Range = line.rangeIncludingLineBreak;\n    let distanceFromCursor: number = Math.abs(cursorPos.line - line.lineNumber);\n\n    let lineText: string = line.text.trim();\n    let tokens: string[] = lineText.split(\" \").filter((token) => {\n        return tokenIsNotKeyword(token);\n    });\n\n    let matches = similar.findBestMatch(pattern, tokens);\n    if(closest) {\n        if (\n            ((matches.bestMatch.rating > closest.rating) ||\n            (matches.bestMatch.rating === closest.rating && distanceFromCursor < closest.distanceFromCursor)) \n        ) {\n            closest = {\n                symbol: matches.bestMatch.target,\n                range: currentLineRange,\n                rating: matches.bestMatch.rating,\n                distanceFromCursor: distanceFromCursor\n            };\n        }\n    } else {\n        closest = {\n            symbol: matches.bestMatch.target,\n            range: currentLineRange,\n            rating: matches.bestMatch.rating,\n            distanceFromCursor: distanceFromCursor\n        };\n    } \n};\n\nconst symbolContainsCursorRange = function(cursorPosition: vscode.Position, symbol: any): vscode.Range | null {\n    if(symbol.kind === vscode.SymbolKind.Function) {\n        if(symbol.range.contains(cursorPosition)) {\n            return symbol.range;\n        } else {\n            return null;\n        }\n    } else if(symbol.kind === vscode.SymbolKind.Object) {\n        // check children for functions\n        let childSymbols = symbol.children;\n        for(let i = 0; i < childSymbols.length; ++i) {\n            let possibleRange: vscode.Range | null = symbolContainsCursorRange(cursorPosition, childSymbols[i]);\n            if(possibleRange) {\n                return possibleRange;\n            } \n        }\n        return null;\n    } else {\n        return null;\n    }\n};\n\nconst closestSymbolInsideBlock = async function(pattern: string): Promise<vscode.Range | undefined> {\n    let document: vscode.TextDocument = vscode.window.activeTextEditor?.document!;\n    let cursorPositon: vscode.Position = vscode.window.activeTextEditor?.selection.active!;\n\n    let currentSymbols: any = await vscode.commands.executeCommand(\"vscode.executeDocumentSymbolProvider\", document.uri);\n\n    let closestFunctionRange: vscode.Range | null = null;\n\n    // get current function the cursor is inside.\n    for(var i = 0; i < currentSymbols.length; ++i) {\n        let matchedCursorRange: vscode.Range | null = symbolContainsCursorRange(cursorPositon, currentSymbols[i]);\n        if(matchedCursorRange) {\n            closestFunctionRange = matchedCursorRange;\n            break;\n        }\n    }\n\n    // Iterate over the lines of the function; if they contain the partial match, return first.\n    if(closestFunctionRange) {\n        let startLineOfCurFunction: number = closestFunctionRange.start.line;\n        let endLineOfCurFunction: number = closestFunctionRange.end.line;\n\n        for(let lineInc = startLineOfCurFunction; lineInc <= endLineOfCurFunction; ++lineInc) {\n            let lineFromDoc: vscode.TextLine = document.lineAt(lineInc);\n            if(!lineFromDoc.isEmptyOrWhitespace) {\n                await checkLineRangeForSymbolMatch(pattern, lineFromDoc, cursorPositon);\n            }\n        }\n\n        if(closest) {\n            let currentLineRange = closest.range;\n        \n            return currentLineRange;\n        }\n    }\n\n};  \n\nfunction isNumber(value: string | undefined): boolean {\n   return ((value != undefined) &&\n           (value != null) &&\n           (value !== '') &&\n           !isNaN(Number(value.toString())));\n}\n\nexport const closestSymbolMatch = async function() {\n    // 1. Check command pallete input. If contains `:` in first piece check if goto-line logic can be applied.\n    // 2. If is a pure letter combo, then can go to closest editor buffer match.\n\n    let outputFromUser: string | undefined = await vscode.window.showInputBox();\n\n    if(isNumber(outputFromUser)) {\n        await gotoLineByNumber(+outputFromUser!);\n    } else {\n        if(outputFromUser) {\n            closest = null;\n            let foundWordMatchRange: vscode.Range | undefined = await closestSymbolInsideBlock(outputFromUser);\n            if(foundWordMatchRange) {\n                await gotoRange(foundWordMatchRange);\n            }\n        }\n    }\n};","module.exports = require(\"vscode\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// The module 'vscode' contains the VS Code extensibility API\n// Import the module and reference it with the alias vscode in your code below\nimport * as vscode from 'vscode';\nimport { closestSymbolMatch } from './closestSymbol';\n\n// This method is called when your extension is activated\n// Your extension is activated the very first time the command is executed\nexport async function activate(context: vscode.ExtensionContext) {\n\n\t// Use the console to output diagnostic information (console.log) and errors (console.error)\n\t// This line of code will only be executed once when your extension is activated\n\tconsole.log('\"closest-symbol\" is now active');\n\n\t// The command has been defined in the package.json file\n\t// Now provide the implementation of the command with registerCommand\n\t// The commandId parameter must match the command field in package.json\n\tlet disposable = vscode.commands.registerCommand('closest-symbol.goToClosest', async () => {\n\t\t// The code you place here will be executed every time your command is executed\n\t\t// Display a message box to the user\n\t\tawait closestSymbolMatch();\n\t});\n\n\tcontext.subscriptions.push(disposable);\n}\n\n// This method is called when your extension is deactivated\nexport function deactivate() {}\n"],"names":["compareTwoStrings","first","second","replace","length","firstBigrams","Map","i","bigram","substring","count","has","get","set","intersectionSize","module","exports","findBestMatch","mainString","targetStrings","Array","isArray","find","s","areArgsValid","Error","ratings","bestMatchIndex","currentTargetString","currentRating","push","target","rating","bestMatch","closest","checkLineRangeForSymbolMatch","async","pattern","line","cursorPos","currentLineRange","rangeIncludingLineBreak","distanceFromCursor","Math","abs","lineNumber","tokens","text","trim","split","filter","token","tokenIsNotKeyword","matches","similar","symbol","range","symbolContainsCursorRange","cursorPosition","kind","vscode","SymbolKind","Function","contains","Object","childSymbols","children","possibleRange","closestSymbolMatch","outputFromUser","window","showInputBox","undefined","value","isNaN","Number","toString","foundWordMatchRange","document","activeTextEditor","cursorPositon","selection","active","currentSymbols","commands","executeCommand","uri","closestFunctionRange","matchedCursorRange","startLineOfCurFunction","start","endLineOfCurFunction","end","lineInc","lineFromDoc","lineAt","isEmptyOrWhitespace","closestSymbolInsideBlock","startLineNumber","startColumn","endLineNumber","endColumn","gotoRange","gotoLineByNumber","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","context","console","log","disposable","registerCommand","subscriptions"],"sourceRoot":""}